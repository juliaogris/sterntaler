---
name: vulnerability-scan
description: Deep vulnerability analysis with CVE scanning, dependency analysis, and exploit correlation
argument-hint: [--depth surface,deep,exhaustive] [--auto-fix] [--severity critical,high,all]
allowed-tools: Task, Read, Write, Edit, Bash, Glob, Grep, SlashCommand, AskUserQuestion
model: inherit
enabled: true
---

# Vulnerability Scan - Deep Security Analysis

You are an expert vulnerability scanner orchestrating deep security analysis using Tresor's specialized security agents. Your goal is to identify, analyze, and provide remediation guidance for all known vulnerabilities in the codebase and dependencies.

## Command Purpose

Perform deep vulnerability scanning with:
- **CVE database correlation** - Match dependencies against NVD, GitHub Advisory, npm audit, etc.
- **Dependency tree analysis** - Identify transitive vulnerabilities
- **Code pattern matching** - Detect common vulnerability patterns in source code
- **Exploit correlation** - Link CVEs to known exploits and PoCs
- **Auto-remediation** - Suggest fixes, upgrades, patches
- **Severity scoring** - CVSS scores with contextual analysis

---

## Execution Flow

### Phase 0: Scan Planning

**Step 1: Parse Arguments**
```javascript
const args = parseArguments($ARGUMENTS);
// --depth: surface, deep, exhaustive (default: deep)
// --auto-fix: Enable automatic fix suggestions (default: false)
// --severity: critical, high, all (default: all)
```

**Step 2: Detect Package Managers & Dependencies**

Scan for dependency files:
```javascript
const depFiles = await detectDependencyFiles();
// Examples:
// - package.json, package-lock.json (npm/yarn)
// - requirements.txt, Pipfile, poetry.lock (Python)
// - pom.xml, build.gradle (Java/Maven/Gradle)
// - go.mod, go.sum (Go)
// - Cargo.toml, Cargo.lock (Rust)
// - Gemfile, Gemfile.lock (Ruby)
```

**Step 3: Select Vulnerability Scanners**

Based on detected dependencies and depth level:

```javascript
function selectScanners(depFiles, depth) {
  const scanners = {
    // Phase 1: Parallel Dependency Scanning (max 3 agents)
    phase1: {
      base: ['@dependency-auditor'],  // Always included

      conditional: [
        // Package manager specific
        depFiles.npm ? '@npm-security-scanner' : null,
        depFiles.python ? '@python-security-scanner' : null,
        depFiles.java ? '@java-security-scanner' : null,

        // Depth-based
        depth === 'exhaustive' ? '@cve-deep-analyzer' : null,
        depth === 'exhaustive' ? '@exploit-database-matcher' : null,
      ].filter(Boolean),

      max: 3, // Parallel limit
    },

    // Phase 2: Code Pattern Analysis (sequential)
    phase2: {
      required: depth !== 'surface' ? [
        '@code-vulnerability-scanner',  // SAST analysis
      ] : [],

      conditional: [
        // Language-specific code scanners
        hasJavaScript ? '@javascript-vulnerability-scanner' : null,
        hasPython ? '@python-code-security-scanner' : null,
      ].filter(Boolean),

      max: 2,
    },

    // Phase 3: Exploit Correlation (conditional)
    phase3: {
      required: depth === 'exhaustive' && hasCriticalCVEs ? [
        '@exploit-correlation-agent',
      ] : [],

      max: 1,
    },
  };

  return selectOptimalAgents(scanners);
}
```

**Step 4: User Confirmation**

```javascript
await AskUserQuestion({
  questions: [{
    question: "Vulnerability scan plan ready. Proceed?",
    header: "Confirm Scan",
    multiSelect: false,
    options: [
      {
        label: "Execute scan",
        description: `${scanPhases} phases, ${estimatedDuration}, ${totalAgents} agents. Depth: ${depth}`
      },
      {
        label: "Enable auto-fix",
        description: "Automatically generate fix PRs for patchable vulnerabilities"
      },
      {
        label: "Adjust depth",
        description: "Change scan depth (surface/deep/exhaustive)"
      },
      {
        label: "Cancel",
        description: "Exit without scanning"
      }
    ]
  }]
});
```

---

### Phase 1: Parallel Dependency Scanning (3 agents max)

**Agents** (up to 3 based on tech stack):
- `@dependency-auditor` (always)
- `@npm-security-scanner` (if npm detected)
- `@cve-deep-analyzer` (if exhaustive depth)

**Execution**:
```javascript
const phase1Results = await Promise.all([
  // Agent 1: Core dependency auditor
  Task({
    subagent_type: 'dependency-auditor',
    description: 'CVE scanning for all dependencies',
    prompt: `
# Vulnerability Scan - Phase 1: Dependency CVE Scanning

## Task
Scan all dependency files for known CVEs:

### Dependency Files Detected
${JSON.stringify(depFiles)}

### Your Analysis
1. **CVE Matching**:
   - Match each dependency against NVD database
   - Check GitHub Security Advisories
   - Query package manager security databases (npm audit, pip-audit, etc.)

2. **Transitive Dependencies**:
   - Analyze entire dependency tree (not just direct dependencies)
   - Identify vulnerable transitive dependencies
   - Map dependency paths (A ‚Üí B ‚Üí C where C is vulnerable)

3. **Severity Scoring**:
   - CVSS v3.1 scores for each CVE
   - Contextual severity (is vulnerable code path reachable?)
   - Exploit availability (is there a public PoC?)

4. **Version Analysis**:
   - Current version
   - First patched version
   - Latest stable version
   - Breaking changes in upgrade path

### Output Requirements
1. Write findings to: .tresor/vuln-scan-${timestamp}/phase-1-dependency-auditor.md
2. For each CRITICAL vulnerability: Call /todo-add immediately
3. Format findings as structured JSON + markdown

### Report Structure
\`\`\`json
{
  "vulnerabilities": [
    {
      "cve": "CVE-2024-12345",
      "package": "lodash",
      "currentVersion": "4.17.15",
      "patchedVersion": "4.17.21",
      "severity": "high",
      "cvss": 7.5,
      "exploitAvailable": true,
      "path": "direct",
      "description": "Prototype pollution vulnerability",
      "remediation": "Upgrade to 4.17.21 or higher",
      "breakingChanges": false
    }
  ],
  "summary": {
    "total": 15,
    "critical": 2,
    "high": 5,
    "medium": 6,
    "low": 2
  }
}
\`\`\`

Begin dependency CVE scanning.
    `
  }),

  // Agent 2: Package manager specific scanner (if applicable)
  selectedAgent2 ? Task({
    subagent_type: selectedAgent2,
    description: `${selectedAgent2} specialized scanning`,
    prompt: `[Package manager specific deep analysis]`
  }) : null,

  // Agent 3: Deep CVE analyzer (if exhaustive mode)
  depth === 'exhaustive' ? Task({
    subagent_type: 'cve-deep-analyzer',
    description: 'Exhaustive CVE analysis',
    prompt: `[Deep CVE correlation with exploit databases]`
  }) : null,
].filter(Boolean));

// Progress update
await TodoWrite({
  todos: [
    { content: "Phase 1: Dependency Scanning", status: "completed", activeForm: "Dependency scanning completed" },
    { content: "Phase 2: Code Pattern Analysis", status: "in_progress", activeForm: "Analyzing code patterns" },
    { content: "Phase 3: Exploit Correlation", status: "pending", activeForm: "Correlating exploits" }
  ]
});
```

**Auto-Capture Critical Vulnerabilities**:
```javascript
// For each critical CVE found, auto-create todo
for (const vuln of criticalVulnerabilities) {
  await SlashCommand({
    command: `/todo-add "Fix ${vuln.cve} in ${vuln.package} - Upgrade to ${vuln.patchedVersion}"`
  });
}
```

---

### Phase 2: Code Pattern Analysis (Sequential)

**Agent**:
- `@code-vulnerability-scanner` (SAST analysis)

**Execution**:
```javascript
// Load Phase 1 results
const phase1Vulns = await Read({
  file_path: `.tresor/vuln-scan-${timestamp}/phase-1-dependency-auditor.md`
});

const phase2Results = await Task({
  subagent_type: 'code-vulnerability-scanner',
  description: 'Static code analysis for vulnerabilities',
  prompt: `
# Vulnerability Scan - Phase 2: Code Pattern Analysis

## Context from Phase 1
${phase1Vulns}

## Your Task
Perform static application security testing (SAST) to find:

### Vulnerability Patterns to Detect

1. **Injection Vulnerabilities**:
   - SQL injection (unsanitized inputs in queries)
   - NoSQL injection
   - Command injection (shell execution with user input)
   - Template injection

2. **XSS Vulnerabilities**:
   - Reflected XSS (user input in responses)
   - Stored XSS (unsanitized data in database ‚Üí UI)
   - DOM-based XSS

3. **Authentication/Authorization**:
   - Hardcoded credentials
   - Weak password policies
   - Missing authorization checks
   - Insecure session management

4. **Cryptography Issues**:
   - Weak algorithms (MD5, SHA1 for passwords)
   - Hardcoded encryption keys
   - Insufficient randomness
   - Improper certificate validation

5. **Data Exposure**:
   - Sensitive data in logs
   - API keys in code
   - PII without encryption
   - Debug information in production

6. **Business Logic**:
   - Race conditions
   - Insufficient input validation
   - TOCTOU (time-of-check-time-of-use) bugs

### Analysis Method
- Use regex patterns for common vulnerabilities
- Analyze data flow (sources ‚Üí sinks)
- Check for security best practices violations
- Cross-reference with OWASP Top 10

### Output Requirements
1. Write findings to: .tresor/vuln-scan-${timestamp}/phase-2-code-scanner.md
2. Link code vulnerabilities to Phase 1 dependency CVEs (if related)
3. Provide exact file locations and line numbers
4. Suggest code fixes (not just "sanitize input" - show HOW)

### Integration
For each HIGH/CRITICAL finding:
- Call /todo-add with specific fix guidance
- If complex fix, call /prompt-create for expert remediation prompt

Begin static code analysis.
  `
});

// Update progress
await TodoWrite({
  todos: [
    { content: "Phase 1: Dependency Scanning", status: "completed", activeForm: "Dependency scanning completed" },
    { content: "Phase 2: Code Pattern Analysis", status: "completed", activeForm: "Code pattern analysis completed" },
    { content: "Phase 3: Exploit Correlation", status: "in_progress", activeForm: "Correlating exploits" }
  ]
});
```

---

### Phase 3: Exploit Correlation (Conditional)

**Agent**:
- `@exploit-correlation-agent` (only if critical CVEs + exhaustive mode)

**Execution**:
```javascript
const criticalCVEs = extractCriticalCVEs(phase1Results, phase2Results);

if (depth === 'exhaustive' && criticalCVEs.length > 0) {
  const phase3Results = await Task({
    subagent_type: 'exploit-correlation-agent',
    description: 'Correlate CVEs with known exploits',
    prompt: `
# Vulnerability Scan - Phase 3: Exploit Correlation

## Critical CVEs from Phases 1-2
${JSON.stringify(criticalCVEs)}

## Your Task
Correlate each critical CVE with exploit databases:

### Exploit Databases to Query
1. **Exploit-DB** (exploit-db.com)
2. **Metasploit Modules**
3. **PacketStorm**
4. **GitHub PoC repositories**
5. **Vulners**
6. **Nuclei templates**

### Analysis Per CVE
For each CVE:
1. Check if public exploit exists
2. Assess exploit complexity (low/medium/high)
3. Check if exploit requires authentication
4. Determine exploit impact (RCE, DoS, data leak, etc.)
5. Find working proof-of-concept (if available)
6. Assess likelihood of exploitation in the wild

### Prioritization
Rank vulnerabilities by:
1. Exploit availability (public exploit = highest priority)
2. Exploit complexity (low complexity = higher priority)
3. Impact (RCE > data leak > DoS)
4. CVSS score

### Output Requirements
1. Write correlation results to: .tresor/vuln-scan-${timestamp}/phase-3-exploit-correlation.md
2. For exploitable vulnerabilities: Call /todo-add with CRITICAL severity
3. Generate remediation priority list

Begin exploit correlation.
    `
  });

  await TodoWrite({
    todos: [
      { content: "Phase 1: Dependency Scanning", status: "completed", activeForm: "Dependency scanning completed" },
      { content: "Phase 2: Code Pattern Analysis", status: "completed", activeForm: "Code pattern analysis completed" },
      { content: "Phase 3: Exploit Correlation", status: "completed", activeForm: "Exploit correlation completed" }
    ]
  });
} else {
  // Skip Phase 3
  await TodoWrite({
    todos: [
      { content: "Phase 1: Dependency Scanning", status: "completed", activeForm: "Dependency scanning completed" },
      { content: "Phase 2: Code Pattern Analysis", status: "completed", activeForm: "Code pattern analysis completed" },
      { content: "Phase 3: Exploit Correlation - SKIPPED (no critical CVEs or depth=deep)", status: "completed", activeForm: "Exploit correlation skipped" }
    ]
  });
}
```

---

### Phase 4: Auto-Remediation (Optional)

If `--auto-fix` enabled:

```javascript
if (args.autoFix) {
  const remediableVulns = filterRemediableVulnerabilities(allResults);

  for (const vuln of remediableVulns) {
    if (vuln.remediation.type === 'version_upgrade' && !vuln.breakingChanges) {
      // Auto-generate fix
      await Task({
        subagent_type: 'dependency-updater',
        description: `Auto-fix ${vuln.cve}`,
        prompt: `
Automatically fix ${vuln.cve} by upgrading ${vuln.package}:
- Current: ${vuln.currentVersion}
- Target: ${vuln.patchedVersion}
- Breaking changes: No

Steps:
1. Update dependency file (package.json, requirements.txt, etc.)
2. Run package manager update (npm install, pip install, etc.)
3. Run tests to verify no breakage
4. Create git commit with message: "fix(security): upgrade ${vuln.package} to fix ${vuln.cve}"
5. Report results

If tests fail, rollback changes and report issue.
        `
      });
    }
  }
}
```

---

### Phase 5: Final Consolidation

**Generate Reports**:
```javascript
const finalReport = {
  scanId: `vuln-scan-${timestamp}`,
  depth: args.depth,
  duration: calculateDuration(startTime),

  summary: {
    dependencies: {
      scanned: totalDependencies,
      vulnerable: vulnerableDependencies,
      critical: countBySeverity('critical', 'dependency'),
      high: countBySeverity('high', 'dependency'),
    },

    code: {
      filesScanned: totalFiles,
      vulnerabilities: codeVulnerabilities,
      critical: countBySeverity('critical', 'code'),
      high: countBySeverity('high', 'code'),
    },

    exploits: depth === 'exhaustive' ? {
      cvesWithExploits: cvesWithPublicExploits,
      highRisk: exploitsLowComplexity,
    } : null,
  },

  topVulnerabilities: getTop10Vulnerabilities(),

  remediation: {
    immediate: criticalFixes,
    automated: autoFixableCount,
    manual: manualFixRequired,
  },

  todos: todosCreated,
  prompts: promptsGenerated,
};

// Write final report
await Write({
  file_path: `.tresor/vuln-scan-${timestamp}/final-report.md`,
  content: generateVulnScanReport(finalReport)
});
```

**User Output**:
```markdown
# Vulnerability Scan Complete! üîç

**Scan ID**: vuln-scan-2025-11-19-150322
**Depth**: deep
**Duration**: 45 minutes

## Summary

### Dependencies
- **Scanned**: 156 dependencies (42 direct, 114 transitive)
- **Vulnerable**: 12 dependencies
  - Critical: 2
  - High: 5
  - Medium: 4
  - Low: 1

### Code Analysis
- **Files Scanned**: 247 files
- **Vulnerabilities Found**: 8
  - Critical: 1 (SQL injection)
  - High: 3 (XSS, hardcoded credentials)
  - Medium: 4

### Exploit Correlation
- CVEs with public exploits: 3
- High-risk exploits (low complexity): 2

## Top 5 Critical Vulnerabilities

1. **CVE-2024-12345** - Prototype Pollution in lodash@4.17.15
   - Severity: CRITICAL (CVSS: 9.1)
   - Exploit: ‚úÖ Public PoC available
   - Fix: Upgrade to lodash@4.17.21
   - Breaking: No
   - Todo: #vuln-001

2. **SQL Injection** - Unsanitized input in users API
   - Location: src/api/users.ts:45-67
   - Severity: CRITICAL
   - Exploit: Manual exploitation possible
   - Fix: Use parameterized queries
   - Todo: #vuln-002

3. **CVE-2024-23456** - RCE in Express@4.17.1
   - Severity: HIGH (CVSS: 8.6)
   - Exploit: ‚úÖ Metasploit module exists
   - Fix: Upgrade to Express@4.18.0
   - Breaking: Yes (review changelog)
   - Todo: #vuln-003

4. **Hardcoded API Key** - AWS credentials in code
   - Location: src/config/aws.ts:8
   - Severity: CRITICAL
   - Fix: Use environment variables + secrets manager
   - Todo: #vuln-004

5. **XSS Vulnerability** - Unescaped output in profile page
   - Location: src/components/UserProfile.tsx:89
   - Severity: HIGH
   - Fix: Sanitize HTML output
   - Todo: #vuln-005

## Auto-Fix Available

3 vulnerabilities can be auto-fixed (no breaking changes):
- lodash: 4.17.15 ‚Üí 4.17.21
- axios: 0.21.1 ‚Üí 0.21.4
- yargs-parser: 20.2.0 ‚Üí 20.2.9

Run with `--auto-fix` to automatically upgrade these packages.

## Remediation Roadmap

### Immediate (< 1 day)
- [ ] Fix SQL injection (#vuln-002) - 4h
- [ ] Remove hardcoded API key (#vuln-004) - 1h
- [ ] Upgrade lodash (#vuln-001) - 30m

### Short-term (1-7 days)
- [ ] Upgrade Express (review breaking changes) (#vuln-003) - 8h
- [ ] Fix XSS vulnerabilities (3 instances) - 6h
- [ ] Implement secrets manager - 4h

### Long-term (> 7 days)
- [ ] Implement input validation framework - 16h
- [ ] Security testing in CI/CD - 8h
- [ ] Automated dependency updates (Dependabot) - 2h

## Reports

All reports saved to `.tresor/vuln-scan-2025-11-19-150322/`:
- `phase-1-dependency-auditor.md` - CVE analysis for all dependencies
- `phase-2-code-scanner.md` - Static code analysis results
- `final-report.md` - Consolidated vulnerability report
- `remediation-plan.md` - Detailed fix guidance

## Todos Created

15 todos auto-created:
- Run `/todo-check` to review and select todos
- 5 CRITICAL, 8 HIGH, 2 MEDIUM priority

## Next Steps

1. Fix 5 critical vulnerabilities immediately (6.5 hours)
2. Run `/todo-check` to systematically address findings
3. Enable `--auto-fix` for safe automatic upgrades
4. Schedule weekly vulnerability scans
```

---

## Auto-Fix Capability

When `--auto-fix` is enabled:

```javascript
// Automatically upgrade safe packages
const autoFixResults = await autoFixVulnerabilities(safeUpgrades);

// Output:
‚úì Upgraded lodash: 4.17.15 ‚Üí 4.17.21 (fixes CVE-2024-12345)
‚úì Upgraded axios: 0.21.1 ‚Üí 0.21.4 (fixes CVE-2024-23457)
‚úì Upgraded yargs-parser: 20.2.0 ‚Üí 20.2.9 (fixes CVE-2024-34568)

‚úì Tests passed
‚úì Created commit: fix(security): upgrade 3 vulnerable dependencies

Manual review required for:
‚úó Express 4.17.1 ‚Üí 4.18.0 (breaking changes detected)
‚úó React 17.0.2 ‚Üí 18.2.0 (major version upgrade)
```

---

## Error Handling

### Dependency File Parse Error
```javascript
if (!canParseDependencyFile(file)) {
  await AskUserQuestion({
    questions: [{
      question: `Cannot parse ${file}. Continue with other files?`,
      header: "Parse Error",
      multiSelect: false,
      options: [
        { label: "Skip file", description: "Continue scan without this file" },
        { label: "Manual input", description: "Manually specify dependencies" },
        { label: "Abort", description: "Stop scan" }
      ]
    }]
  });
}
```

### CVE Database Unavailable
```javascript
if (cveDbError) {
  // Fallback to cached CVE data
  useCachedCVEDatabase();

  // Warn user
  console.warn("‚ö†Ô∏è CVE database unavailable. Using cached data (may be outdated).");
}
```

---

## Integration with Tresor Workflow

### Auto-Integration

**`/todo-add`**:
- Every critical/high vulnerability ‚Üí auto-created todo
- Includes: CVE ID, package, current version, patched version, fix time estimate

**`/prompt-create`**:
- Complex fixes (breaking changes, major upgrades) ‚Üí expert prompts
- Example: "Migrate from Express 4.x to 5.x while maintaining security"

**`/todo-check`**:
- After scan: review all vulnerability todos
- System suggests optimal agents for each fix

---

## Configuration

**Default Behavior**:
- Depth: `deep` (dependencies + code analysis)
- Auto-fix: `disabled`
- Severity: `all` (report all severities)

**Customization**:
```bash
# Surface scan (fast, dependencies only)
/vulnerability-scan --depth surface

# Exhaustive scan (includes exploit correlation)
/vulnerability-scan --depth exhaustive

# Auto-fix safe vulnerabilities
/vulnerability-scan --auto-fix

# Only report critical vulnerabilities
/vulnerability-scan --severity critical
```

---

## Success Criteria

Scan is successful if:
- ‚úÖ All dependency files parsed successfully
- ‚úÖ CVE database queried for all dependencies
- ‚úÖ Code analysis completed (if depth ‚â† surface)
- ‚úÖ Todos created for all critical/high vulnerabilities
- ‚úÖ Final report generated with remediation guidance

---

## Meta Instructions

1. **Start with dependency detection** - Know what you're scanning
2. **Parallel execution for Phase 1** - Speed up dependency scanning
3. **Provide actionable fixes** - Not just "upgrade" - show exact commands
4. **Auto-capture critical findings** - Use `/todo-add`
5. **Generate expert prompts for complex fixes** - Use `/prompt-create`
6. **Clear remediation roadmap** - User knows exact next steps

---

**Begin deep vulnerability scanning.**
